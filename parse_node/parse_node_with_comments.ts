import ts from "typescript"
import {
  ParseNodeType,
  parseNodeWithoutComments,
  ParseState,
} from "../parse_node"
import { Test } from "../tests/test"

const getBackwardsClosestNewLinesCount = (text: string, pos: number) => {
  let count = 0

  for (let i = pos - 1; i >= 0; i--) {
    const char = text.charAt(i)
    if (char === "\t" || char === " ") {
      continue
    }

    if (char === "\n") {
      count++
      continue
    }

    break
  }

  return count
}

export const parseNodeWithComments = (
  node: ts.Node,
  props: ParseState
): ParseNodeType => {
  if (ts.isSourceFile(node)) {
    return parseNodeWithoutComments(node, props)
  }

  let leadingComments =
    ts
      .getLeadingCommentRanges(
        node.getSourceFile().getFullText(),
        node.getFullStart()
      )
      ?.filter((v) => v.kind === ts.SyntaxKind.SingleLineCommentTrivia) ?? []

  let tarilingComments =
    ts
      .getTrailingCommentRanges(
        node.getSourceFile().getFullText(),
        node.getFullStart() + node.getFullWidth()
      )
      ?.filter((v) => v.kind === ts.SyntaxKind.SingleLineCommentTrivia) ?? []

  let commentStackUnwind = props.commentsStack?.length ?? 0

  if (leadingComments.length > 0 || tarilingComments.length > 0) {
    if (!props.commentsStack) {
      props.commentsStack = []
    }

    leadingComments = leadingComments.filter(
      (v) =>
        !props.commentsStack!.find((c) => c.pos === v.pos && c.end === v.end)
    )
    tarilingComments = tarilingComments.filter(
      (v) =>
        !props.commentsStack!.find((c) => c.pos === v.pos && c.end === v.end)
    )

    props.commentsStack.push(...leadingComments, ...tarilingComments)
  }

  const result = parseNodeWithoutComments(node, props)

  if (leadingComments.length > 0 || tarilingComments.length > 0) {
    const fullText = node.getSourceFile().getFullText()

    if (leadingComments.length > 0) {
      const leadingCommentsText = leadingComments.map(
        (v) => "#" + fullText.slice(v.pos + 2, v.end)
      )
      const addFirstNewLineToLeadingComments =
        getBackwardsClosestNewLinesCount(fullText, leadingComments[0].pos) >
          1 || !result.content.endsWith("\n")

      result.content =
        (addFirstNewLineToLeadingComments ? "\n" : "") +
        leadingCommentsText.join("\n") +
        "\n" +
        result.content
    }

    if (tarilingComments.length > 0) {
      const trailingCommentsText = tarilingComments.map(
        (v) => "#" + fullText.slice(v.pos + 2, v.end)
      )
      const addFirstNewLineToTrailingComments =
        getBackwardsClosestNewLinesCount(fullText, tarilingComments[0].pos) > 0

      result.content =
        result.content +
        (addFirstNewLineToTrailingComments ? "\n" : " ") +
        trailingCommentsText.join("\n") +
        "\n"
    }

    props.commentsStack!.length = commentStackUnwind
  }

  return result
}

export const testComments: Test = {
  keepComments: true,
  ts: `
// This is a test class
// abc
class Test extends Area2D {
  // This a constructor
  constructor() {
    // This is a super call

  }

  // this is a method
  method() {
    // this is a print
    print("a")

    // This is an if statement
    if (2 == 3) {
      // This is an empty block
    }

    print(/* this is block comment */"l")

    print(
      // this is a call with parameters in multiple lines
      "hello",
      // this is second parameter
      "world"
    )

    // this is a print
    // this is a print
    // and this is third comment
    print("b")

    print("x") // leading comment
  }
}
    `,
  expected: `
# This file has been autogenerated by ts2gd. DO NOT EDIT!
extends Area2D
class_name Test
# This is a test class
# abc
# This a constructor
func _ready():
  pass
# this is a method
func method():
  # this is a print
  print("a")
  # This is an if statement
  if ((typeof(2) == typeof(3)) and (2 == 3)):
    pass
  print("l")
  print(
  # this is a call with parameters in multiple lines
  "hello",
  # this is second parameter
  "world")
  # this is a print
  # this is a print
  # and this is third comment
  print("b")
  print("x") # leading comment
  `,
}
